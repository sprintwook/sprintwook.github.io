---
layout: post
title: 코드잇 스프린트 6기 FE 위클리 페이퍼 5주차
subtitle: CodeIt Sprint Weekly Paper 5th Week
cover-img: /assets/img/path.jpg
thumbnail-img: /assets/img/thumb.png
share-img: /assets/img/path.jpg
tags: ["#코드잇스프린트", "#스프린트프론트엔드6기", "#취업까지달린다" ]
author: Jongwook Lee
---

# 5주차 위클리 과제 안내

<br>

{: .box-note}
**아래 두 가지 주제에 대해서 각자 조사해서 답변을 제출해 주세요.**<br>
**이벤트 버블링, 캡쳐링, 위임에 대해 설명해 주세요.**<br>
**HTTP 메소드에 대해 설명해 주세요.**<br>
**제출은 위클리 페이퍼 답안 제출 설문에 일요일 23시 59분까지 해주시면 됩니다.**<br>



<br>

## 조사 내용

#### 1. 이벤트 버블링, 캡쳐링, 위임에 대해 설명해 주세요.
- 이벤트 버블링/캡쳐링/위임에 대한 이해를 하기 위해선 이벤트 전파 흐름의 개념을 이해해야 한다.
	- 먼저 HTML 문서의 각 엘리먼트들은 태그 안의 태그가 위치하는 식으로 계층적으로 이뤄져 있다.
		- 계층적 구조 특징으로 인해 HTML 요소에 이벤트가 발생하는 경우 연쇄적인 이벤트 흐름이 발생된다.
		- 간단한 예시 코드는 아래와 같다.
		```
		<form onclick="console.log('form')">FORM
		<div onclick="console.log('div')">DIV
			<p onclick="console.log('p')">P</p>
		</div>
		</form>
		```
		- 위의 내용에서 p -> div -> form의 내용이 콘솔에서 출력되는 것을 확인할 수 있다.
		```
		p
		div
		form
		```
		- 이러한 현상을 이벤트 전파(Event Propagation)이라고 부르며, 전파 방향에 따라 버블링과 캡쳐링으로 구분이 된다.
		- 이벤트 전파 흐름은 하기의 3단계 흐름으로 발생된다.
			1. 캡쳐링 단계 : 이벤트가 하위 요소로 전파되는 단계, 해당 특성으로 인해 이벤트 위임이 가능
			2. 타깃 단계 : 이벤트가 실제 타깃 요소에 전달되는 단계
			3. 버블링 단계 : 이벤트가 상위 요소로 전파되는 단계, 해당 특성으로 인해 이벤트 전파가 가능
		- 브라우저는 사용자로부터 이벤트가 발생되면 가장 상단 요소부터 하위 요소까지 내려오고 다시 거슬러 올라가는 식으로 이벤트를 전달하여 발생시킨다.
			- 타깃 요소까지 이벤트를 전파하는 과정에서 그 요소의 부모, 조상에도 이벤트 리스너가 등록되어 있으면 실행하게 된다.
	- 이벤트 전파가 발생되는 이유는 자식 요소가 부모 요소 영역에	 위치해 있으므로, 자식 요소만 클릭하여도 부모 요소를 클릭한 것이 되기 때문이다.
		- 이벤트 전파를 잘 이용하면 이벤트 등록 코드를 줄일 수 있다는 장점이 존재한다.
		- 이벤트 전파 개념이 없으면 일일히 요소마다 이벤트를 등록해야 하는 문제점이 존재한다. (적으면 문제 없으나 극악으로 많은 경우엔 문제점이 된다.)
	
- 이벤트 버블링이란, 한 요소에 이벤트가 발생하면 이 요소에 할당된 핸들러가 동작하고, 이어서 부모 요소의 핸들러가 동작하고 최상단의 부모 요소를 만날 때까지 반복되면서 핸들러가 동작되는 현상을 의미한다.
	- 즉, 자식 요소에서 발생한 이벤트가 바깥 부모 요소로 전파된다.
	- 버블링은 한 요소에 이벤트가 발생되면 그 요소의 부모 요소의 이벤트도 같이 발생되는 이벤트 전파를 의미한다.
	- 이벤트가 제일 깊은 곳에 있는 요소에서 시작해 부모 요소를 거슬러 올라가며 발생하는 모양이 물속의 거품을 닮아서 이벤트 버블링으로 명명하게 되었다.
	- 브라우저의 기본 이벤트는 버블링 방식으로 이벤트가 전파되며, 자바스크립트의 addEventListener() 함수로 요소의 이벤트를 등록하면 기본적으로 버블링 전파 방식으로 이벤트가 흐르게 된다.
		- 이 때, 자식 요소에서 이벤트가 발생되면, 부모 요소에도 버블링으로 인해 전파되어, 부모 요소에 등록된 이벤트 리스너도 같이 동작하게 된다.
		- 대부분의 이벤트는 버블링이 발생되나, focus 이벤트와 같이 버블링이 되지 않는 이벤트도 존재한다.
	
- 이벤트 캡쳐링이란, 한 요소에 이벤트가 발생되면, 그 요소의 자식, 자손 요소의 이벤트도 같이 발생되는 이벤트 전파를 의미한다. 
	- 실무상에서는 자주 이용되지 않으나, 가끔 유용한 경우가 존재하므로 알아두면 유용하다.
	- 브라우저의 이벤트 전파 방식은 기본적으로 버블링이므로 캡쳐링으로 설정하기 위해서는 addEventListener() 함수에서 세 번째 인자로 true 값을 전달하면 이벤트 타겟은 캡쳐링을 통해 이벤트를 전파 받아 호출된다.
		- 세 번째 인자의 기본 값은 false로 되어 있다.
		- 옵션 설정을 통해 버블링/캡쳐링을 등록하는 이유는 이벤트 전파 과정에서 브라우저에서 캡쳐링으로 탐색하는 과정에서 이벤트가 발생하고, 버블링으로 이벤트가 발생되면 동일한 이벤트가 중복으로 발생될 수 있기 때문이다.
	- addEventListener() 함수를 이용하여 특정 요소에 각각 버블링과 캡쳐링에 대한 이벤트 리스너를 등록하면 버블링과 캡쳐링을 동시에 발생시키는 것도 가능하다.
	
- 이벤트 버블링과 캡쳐링의 문제점
	- 이벤트 전파 개념상, 캡쳐링이나 버블링으로 인해 등록된 모든 이벤트 리스너가 모두 실행되므로, 이벤트를 발생시키고 싶지 않은 요소에서 이벤트가 발생하는 문제점이 존재한다.
		- 브라우저의 특성상 기본적으로 캡쳐링/버블링으로 동작하기 때문에 이벤트 동작 원리를 변경하는 것은 불가능하다.
		- 이를 위해, e.stopPropagation()이라는 함수를 사용하면 해당 요소에서는 버블링/캡쳐링 설정에 따른 상위/하위로 가능 이벤트 전파를 막을 수 있다.
		- e.stopImmediatePropagation()이라는 함수를 호출하면 이벤트 전파와 더불어 형제 이벤트 실행을 멈추는 것도 가능하다.
			- 해당 함수는 하나의 요소 뿐만이 아닌 같은 형제 요소에서도 이벤트 전파로 인한 영향을 막을 때 유용하게 사용할 수 있다.
	- 위 문제점에 대해 세심한 이벤트 핸들러를 제어하고 싶다면, 조건 분기를 통해 특정 조건에서만 이벤트가 발생되도록 만들 수 있다.		
	- e.preventDefault() 함수는 이벤트 전파 뿐만이 아닌 기본 이벤트 동작 자체를 취소한다.
		- 대표적인 예시로 form의 submit 이벤트는 클릭 이벤트 발생과 동시에 페이지를 새로고침하는 기본 동작을 수행하기 때문에 기존 form에 존재하는 입력 값이 초기화되는 문제가 존재한다.
			- 이 때, 기본 동작 수행을 멈추게 되면, 값만 제출하고 기존 form 내 존재하는 입력 값이 초기화되는 것을 막을 수 있다.
	- 간단한 정리를 하면 하기 표와 같다.
		|   함수명       |    기능 	  |
		| :------------ | :-----------|
		| `e.stopPropagation` | 이벤트 전파 중지 |
		| `e.stopImmediatePropagation`  | 이벤트 전파 중지 + 형제 이벤트 실행 중지 |
		| `e.preventDefault`  | 이벤트 전파 중지 + 형제 이벤트 실행 중지 + 이벤트 기본 동작 중지 |
	- 버블링 이벤트 전파를 막는 e.stopPropagation() 메서드는 추후에 문제가 될 수 있는 상황을 만들 수 있다.
		- 서비스 내 페이지에서 사람들의 행동 패턴을 예측할 때, 이벤트 핸들러를 이용하는데 stopPropagation으로 버블링이 막혀 있는 경우, 죽은 영역이 된다.
		- 이벤트 버블링은 반드시 막아야 되는 문제라면 커스텀 이벤트를 사용하거나, 각 요소의 핸들러의 event 객체에 데이터를 저장하여 처리하는 것이 좋다.

- 이벤트 위임이란,	사용자의 액션에 의해 이벤트 발생 시 이벤트 버블링에 의해 document 레벨까지 버블링 되어 올라가는데 이 때문에 자식 엘리먼트에서 발생하는 이벤트를 부모 엘리먼트에서도 감지할 수 있다.
	- 이벤트 위임을 사용하여, 자식 엘리먼트의 하나하나에 모든 이벤트를 주는 것이 아닌 부모 엘리먼트에 적용하여 자식 요소에 이벤트 발생을 적용하는 방법이다.
	- 이벤트 위임은 동적인 엘리먼트에 대한 이벤트를 관리할 때 굉장히 효율적이다.
	- 이벤트 위임을 적용하면 하기의 사항들이 개편된다.
		- 동적인 엘리먼트에 대한 이벤트 처리가 수월해진다.
		- 상위 엘리먼트에서만 이벤트를 관리하기 때문에 하위 엘리먼트는 자유롭게 추가/삭제할 수 있다.
		- 메모리 사용량이 감소하고, 동일한 이벤트에 대해 한 곳에서 관리하기 때문에 각각의 엘리먼트를 여러 곳에 등록하여 관리하는 것보다 수월해진다.
	
	
<br>	

#### 2. HTTP 메소드에 대해 설명해 주세요.
- HTTP 메소드의 기능을 간단히 정리하면 하기와 표와 같습니다.

	|   메서드명       |    기능 	  | 본문 데이터 존재 여부 | 서버 내 데이터 변경 여부 (안전함) | 다수 요청 시, 중복 허용 여부 (멱등성) | 캐싱 여부 (캐시 가능) |
	| :------------ | :-----------| :-----------| :-----------| :-----------| :-----------|
	| `GET` | 리소스 조회 | 아니오 | 예 | 예 | 예 |
	| `POST`  | 등록, 요청 데이터 처리 | 예 | 아니오 | 아니오 | 신선도 정보 포함 시 |
	| `PUT`  | 리소스 덮어쓰기 (해당 리소스가 없으면 생성) | 예 | 아니오 | 예 | 아니오 |
	| `PATCH`  | 리소스 부분 변경 (PUT은 전체 변경/PATCH는 부분 변경) | 예 | 아니오 | 아니오 | 아니오 |
	| `DELETE`  | 리소스 삭제 | 그럴 수도 있음 | 아니오 | 예 | 아니오 |
	| `HEAD`  | GET하고 동일하나 BODY 부분을 제외하고, 상태 메세지와 헤더만 전달 | 아니오 | 예 | 예 | 예 |
	| `OPTIONS`  | 대상 리소스에 대한 통신 가능 옵션 (메서드)를 설명 (주로 CORS에서 사용) | 아니오 | 예 | 예 | 아니오 |
	| `CONNECT`  | 대상 자원으로 식별되는 서버에 대한 터널을 설정 | 아니오 | 아니오 | 아니오 | 아니오 |
	| `TRACE`  | 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행 | 아니오 | 예 | 예 | 아니오 |

- GET 메서드 : 리소스를 조회하는 메서드로 서버에 전달하고 싶은 데이터는 쿼리 파라미터/쿼리 스트링(?query="")을 통해서 전달한다.
	- 메시지 바디를 사용하여 데이터를 전달할 수도 있으나 지원하지 않는 곳이 많다.
- POST 메서드 : 요청 데이터를 처리하는 메서드로, 메시지 바디를 통해 서버로 요청 데이터를 전달하고 서버는 메시지 바디를 통해 들어온 데이터를 처리하여 응답한다.
	- 신규 리소스를 등록하고, 프로세스 처리에 사용하며 JSON으로 조회 데이터를 넘기는 형태로 주로 처리한다.
	- 단순히 데이터를 생성하거나, 값을 변경하는 것을 넘어 프로세스의 상태가 변경되는 경우에 사용한다. (시스템에 큰 변화 존재 시)
- PUT 메서드 : 리소스가 있다면 요청을 보낸 데이터로 완전히 덮어씌우고, 리소스가 없다면 새로 생성한다.
	- POST와의 차이점은 클라이언트가 리소스의 위치를 알고 URI를 지정한다.
	- POST 요청 시에는 `/users`까지만 지정을 했지만, PUT은 `/user/10`으로 리소스의 위치까지 지정해 요청한다.
	- PUT은 기존 리소스를 완전히 대체하므로 특정 필드만 변경되는 것이 아닌 전체 데이터를 덮어쓰게 된다.
- PATCH 메서드 : 리소스의 부분을 변경한다.
	- PATCH를 지원하지 않는 경우, POST를 사용하여 전달한다.
- DELETE 메서드 : 요청 받은 리소스를 제거한다.
- HEAD 메서드 : 특정 리소스를 GET 메서드로 요청했을 때 돌아올 헤더를 요청한다.
	- HEAD 메서드에 대한 응답은 HEADER만 존재해야 하며, BODY가 존재하면 무시한다.
	- Content-Length와 같은 본문 컨텐츠를 설명하는 개체 헤더는 포함이 가능하다.
- OPTIONS 메서드 : 주어진 URL 또는 서버에 대해 허용된 통신 옵션을 요청한다.
	- 클라이언트는 이 메서드를 이용하여 URL을 지정하거나 `*(Asterisk)`를 지정하여 전체 서버를 참조할 수 있다.
- CONNECT 메서드 : 요청한 리소스에 대해 양방향 연결을 시작하는 메서드로 터널을 열기 위해 사용된다.
	- CONNECT 메서드는 SSL를 사용하는 웹사이트에 접속하는 데 사용된다. 
	- 작동 과정은 하기와 같다.
		- 클라이언트는 원하는 목적지와의 TCP 연결을 HTTP 프록시 서버에 요청한다.
		- 서버는 클라이언트를 대신하여 연결의 생성을 진행한다.
		- 한번 서버에 의해 연결이 수립되면, 프록시 서버는 클라이언트에 오고 가는 TCP 스트림을 계속하여 프록시한다.
- TRACE	메서드 : 특정 경로의 타겟 리소스에게 유용한 디버깅 메커니즘을 제공하기 위한 메세지 루프백 테스트 목적으로 사용한다.
	- 주로 요청에 내용을 보내지 않고, 쿠키나 크리덴셜과 같은 세션 데이터를 생성할 때 사용되는 메서드이다.

	
<br>	

#### 3. 참조

  | Features      | Links                                                  |
  | :------------ | :----------------------------------------------------- |
  | MDN 공식 문서  | [링크로 이동](https://developer.mozilla.org/ko/docs/Web/HTTP/Methods)|
  | 벨로그 | [링크로 이동](https://velog.io/@hovelopin/JS-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%9C%84%EC%9E%84-ax11zcnh) |
  | 인파 개발자 블로그 | [링크로 이동](https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-%EB%B2%84%EB%B8%94%EB%A7%81-%EC%BA%A1%EC%B3%90%EB%A7%81) |
  
  
  